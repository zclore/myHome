# [19.1]
1.
底层支持：中断禁止、定时器、等待队列

同步机制：信号量、管程（条件变量）

同步管理：处理机调度
# [19.2]
1.
定时器的数据结构（timer_t）：所有当前还未触发的定时设置形成一个队列（timer_list）；

定时器的设置函数do_sleep()

定时器的触发流程：trap_dispatch()会检查定时器设置是否触发，并在触发时唤醒相应线程；
2.
static list_entry_t timer_list;

包含wait_queue_t字段的数据结构通常都会对应有一类等待队列
3.
等待队列的数据结构、等待队列操作（等待down()、唤醒up()）

关键的等待队列操作实现函数：wait_current_set(), wakeup_wait()

proc.h中定义了若干种等待状态（如WT_TIMER），通常一种等待状态会对应有一类等待队列
# [19.3]
1.
semaphore_t

由于线程唤醒原因可能与等待标志可能不一致，可能出现不按FIFO排队的情况；

信号量的实现用到了“屏蔽中断”机制；使用wait_current_set()把当前线程放入等待队列；使用wait_current_del()把等待线程唤醒；
2.
信号量的实现用到了“屏蔽中断”机制；使用wait_current_set()把当前线程放入等待队列；使用wait_current_del()把等待线程唤醒；

spinlock只在多处理机环境下有需求，单处理机环境下仅需要“屏蔽中断”；
3.
有多个有小差异的类似函数要使用相同的核心功能实现。类似情况还出现在do_fork()函数。
# [19.4]
1.
等价，原因是可以基于一个机制来实现另一个机制；
2.
入口队列、唤醒队列和条件变量对应的等待队列等队列的实现中都用到了信号量；
3.
monitor.next就是唤醒队列，对应三种管程模型中的hoare管程；
4.
monitor.mutex

monitor.next

condvar.sem
5.
线程A占用管程（0），A进入条件变量等待（1），A唤醒在入口等待队列中等待的线程B（3）

B占用管程（5），B唤醒在条件变量等待队列等待的A(6)，B进入唤醒队列等待（9）

A占用管程（11），A在结束时唤醒在唤醒队列等待的B（13），B占用管程并执行到结束（15）
6.
是的。占用管程的线程在唤醒条件等待队列中的线程后立即进行唤醒队列等待。
# [19.6]
1.
pickup();

putdown();
2.
5个条件变量，每个条件代表一个哲学家；
