# [17.1]
1.
程序执行的结果是实现预期的功能，并且是确定的和可重现的；</br>
我们只能在确定的限制条件下来讨论“正确性”的定义或解释，没有无条件的“正确”。
2.
如果预期行为包括明确的运行环境的限定，这就不是错误；否则就是错误；
3.
好处：共享资源，提高速度，模块化
4.
原子操作是指一次不存在任何中断或失败的操作。
# [17.2]
1.
思路的关键点：有人去买，不会重复买；合理的枚举分类；
- 方案一：先检查，后加相同的标签；漏洞是可能重复采购；
- 方案二：先加相同的标签，后检查；漏洞是会出现没人去买的情况；
- 方案三：先加不同的标签，后检查；漏洞是会出现没人去买的情况；
- 方案四：先加不同的标签，后进行非对称检查；经枚举判断，结果是不会出现漏洞；
- 方案五：原子操作
2.
- 操作系统的进程切换比人的操作切换快；
- 操作系统的进程对外界环境的感知手段比人少；
3.
合理定义枚举分类标准是检查同步算法正确性的关键；
4.
5.
- 互斥：一个进程占用资源，其它进程不能使用；
- 死锁：多个进程各占用部分资源，形成循环等待；
- 饥饿：其他进程可能轮流占用资源，一个进程一直得不到资源；
# [17.3]
1.
进程中访问临界资源的一段需要互斥执行的代码，
2.
空闲则入，忙则等待，有限等待，让权等待。
3.
禁用中断可以阻止其他进程对临界区访问进程的打断。
优点是简单；缺点是无法中断，临界区代码故障可以导致系统崩溃，其他进程可能出现饥饿。
4.
这两条指令在实现原子操作的功能是等价的。
# [17.4]
1.
- 方案一：turn 表示允许进入临界区的线程标识； 方案漏洞：交替进入临界区；
- 方案二：flag[i] 表示线程i是否在临界区； 先判断，后修改变量； 方案漏洞：并发判断后，可能出现同时进入临界区；
- 方案三：flag[i] 表示线程i想要进入临界区； 先修改变量，后判断； 方案漏洞：并发修改变量后，可能出现都无法进入临界区的情况；
- Peterson算法：turn 表示进入临界区的线程标识，flag[i] 表示线程i想要进入临界区； 先修改变量，后判断；后修改者等待； 只适用于两个进程； 方案正确性枚举判断：按写变量的顺序进行情况分类
- Eisenberg算法：flag[i] 表示线程i想要进入临界区，turn 表示进入临界区的线程标识（有多个想进入时）； 进入区：先修改flag，后判断是否有多个想进入；后修改者等待； 退出区：修改turn； 适用于多个进程； 方案正确性枚举判断：按写变量flag[i]的顺序和变量turn当前值进行情况分类
# [17.5]
1.
利用一条指令来实现另一条指令的功能；
2.
自旋锁是基于TS指令实现同步的，进入区的等待是占用CPU的.</br>
无忙等待锁是在自旋锁的基础上加一个等待队列和进程切换，进入区的等待是不占用CPU的.
3.
原子操作指令是硬件实现的，与进程数目无关.</br>
缺点是，等待时占用CPU，可能出现饥饿和死锁.











