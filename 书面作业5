# 5.1
1.抽象，保护，共享，虚拟
# 5.2
1.
- 编译是将高级程序语言（c,c++,c#等）转换成汇编语言，并且将变量翻译成寄存器
- 汇编是将汇编语言转化为机器语言指令，把这些指令打包成可重定位目标程序。
- 链接是将多个编译过的文件组合成一个文件，并且加入程序调用的库函数等所需的其他资源
- 加载是将以上处理过的后生成的指令（二进制码）在执行前加载到内存中，并提供地址翻译。
# 5.3
1.
- 内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间
- 外部碎片指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。
2.
是，因为最先匹配总是先找地址低的内存分配，越到后来低地址内存分配完了，就只能找高地址内存。速度就变慢了。
3.
是，因为最差匹配每次分割最大的空闲内存块，最优匹配每次分割最小的内存块，最差匹配留下的内存块大，能够被另一个进程占用的可能要大。
4.
- 最优匹配，最差匹配，最先匹配都是先找是否有临近的空闲分区，若有就合并。最优匹配和最差匹配还要调整空闲分区列表顺序。
- 伙伴系统合并的是大小相同，地址相邻，低地址空闲块起始地址为2^(i+1)的内存块。
# 5.4
1.
紧凑是通过移动分配给进程的内存分区来合并外部碎片。
分区是抢占并回收处于等待状态进程的分区来增大内存空间。
2.
将进程从硬盘中读取到内存中，在这个过程中，操作系统将该进程标为等待状态并且调度其他进程。
# 5.5
1.
空闲块按大小和起始地址组织成二维数组
2.
- 分配过程：由小到大在空闲块数组中找最小可用空闲块，若空闲块过大，对可用空闲块等分，直到找到合适的可用空闲块。
- 回收过程：将释放的块放入空闲块数组，合并满足合并条件（大小相等，地址相邻，低地址空闲块起始地址为2^（i+1）的位数）的空闲块。
